{"ast":null,"code":"class WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 3000;\n    this.eventHandlers = new Map();\n    this.isConnecting = false;\n  }\n  connect(userId) {\n    var _this$ws;\n    if (((_this$ws = this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.readyState) === WebSocket.OPEN || this.isConnecting) {\n      return Promise.resolve();\n    }\n    this.isConnecting = true;\n    const WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000';\n    return new Promise((resolve, reject) => {\n      try {\n        this.ws = new WebSocket(`${WS_URL}/ws/${userId}`);\n        this.ws.onopen = () => {\n          console.log('WebSocket connected');\n          this.reconnectAttempts = 0;\n          this.isConnecting = false;\n          resolve();\n        };\n        this.ws.onmessage = event => {\n          try {\n            const data = JSON.parse(event.data);\n            this.handleMessage(data);\n          } catch (error) {\n            console.error('Failed to parse WebSocket message:', error);\n          }\n        };\n        this.ws.onerror = error => {\n          console.error('WebSocket error:', error);\n          this.isConnecting = false;\n        };\n        this.ws.onclose = () => {\n          console.log('WebSocket disconnected');\n          this.isConnecting = false;\n          this.handleReconnect(userId);\n        };\n      } catch (error) {\n        console.error('WebSocket connection error:', error);\n        this.isConnecting = false;\n        reject(error);\n      }\n    });\n  }\n  handleReconnect(userId) {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`Reconnecting... Attempt ${this.reconnectAttempts}`);\n      setTimeout(() => {\n        this.connect(userId);\n      }, this.reconnectDelay);\n    } else {\n      console.error('Max reconnection attempts reached');\n    }\n  }\n  handleMessage(data) {\n    const handlers = this.eventHandlers.get(data.type);\n    if (handlers) {\n      handlers.forEach(handler => handler(data));\n    }\n  }\n\n  // Subscribe to events\n  on(eventType, callback) {\n    if (!this.eventHandlers.has(eventType)) {\n      this.eventHandlers.set(eventType, new Set());\n    }\n    this.eventHandlers.get(eventType).add(callback);\n\n    // Return unsubscribe function\n    return () => {\n      const handlers = this.eventHandlers.get(eventType);\n      if (handlers) {\n        handlers.delete(callback);\n      }\n    };\n  }\n\n  // Alias for 'on'\n  subscribeToEvent(eventType, callback) {\n    return this.on(eventType, callback);\n  }\n  sendMessage(message) {\n    var _this$ws2;\n    if (((_this$ws2 = this.ws) === null || _this$ws2 === void 0 ? void 0 : _this$ws2.readyState) === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(message));\n    } else {\n      console.error('WebSocket is not connected');\n    }\n  }\n  joinRoom(roomId) {\n    this.sendMessage({\n      type: 'join_room',\n      room_id: roomId\n    });\n  }\n  sendTyping(roomId, isTyping) {\n    this.sendMessage({\n      type: 'typing',\n      room_id: roomId,\n      is_typing: isTyping\n    });\n  }\n  disconnect() {\n    if (this.ws) {\n      this.reconnectAttempts = this.maxReconnectAttempts; // Prevent reconnection\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n  isConnected() {\n    var _this$ws3;\n    return ((_this$ws3 = this.ws) === null || _this$ws3 === void 0 ? void 0 : _this$ws3.readyState) === WebSocket.OPEN;\n  }\n}\n\n// Create and export a single instance\nconst websocketService = new WebSocketService();\nexport default websocketService;","map":{"version":3,"names":["WebSocketService","constructor","ws","reconnectAttempts","maxReconnectAttempts","reconnectDelay","eventHandlers","Map","isConnecting","connect","userId","_this$ws","readyState","WebSocket","OPEN","Promise","resolve","WS_URL","process","env","REACT_APP_WS_URL","reject","onopen","console","log","onmessage","event","data","JSON","parse","handleMessage","error","onerror","onclose","handleReconnect","setTimeout","handlers","get","type","forEach","handler","on","eventType","callback","has","set","Set","add","delete","subscribeToEvent","sendMessage","message","_this$ws2","send","stringify","joinRoom","roomId","room_id","sendTyping","isTyping","is_typing","disconnect","close","isConnected","_this$ws3","websocketService"],"sources":["E:/Charla_V03/frontend/src/services/websocket.js"],"sourcesContent":["class WebSocketService {\r\n  constructor() {\r\n    this.ws = null;\r\n    this.reconnectAttempts = 0;\r\n    this.maxReconnectAttempts = 5;\r\n    this.reconnectDelay = 3000;\r\n    this.eventHandlers = new Map();\r\n    this.isConnecting = false;\r\n  }\r\n\r\n  connect(userId) {\r\n    if (this.ws?.readyState === WebSocket.OPEN || this.isConnecting) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    this.isConnecting = true;\r\n    const WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000';\r\n    \r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        this.ws = new WebSocket(`${WS_URL}/ws/${userId}`);\r\n\r\n        this.ws.onopen = () => {\r\n          console.log('WebSocket connected');\r\n          this.reconnectAttempts = 0;\r\n          this.isConnecting = false;\r\n          resolve();\r\n        };\r\n\r\n        this.ws.onmessage = (event) => {\r\n          try {\r\n            const data = JSON.parse(event.data);\r\n            this.handleMessage(data);\r\n          } catch (error) {\r\n            console.error('Failed to parse WebSocket message:', error);\r\n          }\r\n        };\r\n\r\n        this.ws.onerror = (error) => {\r\n          console.error('WebSocket error:', error);\r\n          this.isConnecting = false;\r\n        };\r\n\r\n        this.ws.onclose = () => {\r\n          console.log('WebSocket disconnected');\r\n          this.isConnecting = false;\r\n          this.handleReconnect(userId);\r\n        };\r\n      } catch (error) {\r\n        console.error('WebSocket connection error:', error);\r\n        this.isConnecting = false;\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  handleReconnect(userId) {\r\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n      this.reconnectAttempts++;\r\n      console.log(`Reconnecting... Attempt ${this.reconnectAttempts}`);\r\n      setTimeout(() => {\r\n        this.connect(userId);\r\n      }, this.reconnectDelay);\r\n    } else {\r\n      console.error('Max reconnection attempts reached');\r\n    }\r\n  }\r\n\r\n  handleMessage(data) {\r\n    const handlers = this.eventHandlers.get(data.type);\r\n    if (handlers) {\r\n      handlers.forEach(handler => handler(data));\r\n    }\r\n  }\r\n\r\n  // Subscribe to events\r\n  on(eventType, callback) {\r\n    if (!this.eventHandlers.has(eventType)) {\r\n      this.eventHandlers.set(eventType, new Set());\r\n    }\r\n    this.eventHandlers.get(eventType).add(callback);\r\n\r\n    // Return unsubscribe function\r\n    return () => {\r\n      const handlers = this.eventHandlers.get(eventType);\r\n      if (handlers) {\r\n        handlers.delete(callback);\r\n      }\r\n    };\r\n  }\r\n\r\n  // Alias for 'on'\r\n  subscribeToEvent(eventType, callback) {\r\n    return this.on(eventType, callback);\r\n  }\r\n\r\n  sendMessage(message) {\r\n    if (this.ws?.readyState === WebSocket.OPEN) {\r\n      this.ws.send(JSON.stringify(message));\r\n    } else {\r\n      console.error('WebSocket is not connected');\r\n    }\r\n  }\r\n\r\n  joinRoom(roomId) {\r\n    this.sendMessage({\r\n      type: 'join_room',\r\n      room_id: roomId\r\n    });\r\n  }\r\n\r\n  sendTyping(roomId, isTyping) {\r\n    this.sendMessage({\r\n      type: 'typing',\r\n      room_id: roomId,\r\n      is_typing: isTyping\r\n    });\r\n  }\r\n\r\n  disconnect() {\r\n    if (this.ws) {\r\n      this.reconnectAttempts = this.maxReconnectAttempts; // Prevent reconnection\r\n      this.ws.close();\r\n      this.ws = null;\r\n    }\r\n  }\r\n\r\n  isConnected() {\r\n    return this.ws?.readyState === WebSocket.OPEN;\r\n  }\r\n}\r\n\r\n// Create and export a single instance\r\nconst websocketService = new WebSocketService();\r\nexport default websocketService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}