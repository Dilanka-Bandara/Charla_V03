{"ast":null,"code":"class WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 3000;\n    this.eventHandlers = new Map();\n    this.isConnecting = false;\n  }\n\n  // Changed: No longer accepts userId, assumes token is in localStorage\n  connect() {\n    var _this$ws;\n    if (((_this$ws = this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.readyState) === WebSocket.OPEN || this.isConnecting) {\n      return Promise.resolve();\n    }\n    const token = localStorage.getItem('token');\n    if (!token) {\n      console.error('Cannot connect to WebSocket: No token found');\n      return Promise.reject('No token');\n    }\n    this.isConnecting = true;\n    const WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000';\n    return new Promise((resolve, reject) => {\n      try {\n        // CHANGED: Connect using query param token instead of path param\n        this.ws = new WebSocket(`${WS_URL}/ws?token=${token}`);\n        this.ws.onopen = () => {\n          console.log('WebSocket connected');\n          this.reconnectAttempts = 0;\n          this.isConnecting = false;\n          resolve();\n        };\n        this.ws.onmessage = event => {\n          try {\n            const data = JSON.parse(event.data);\n            this.handleMessage(data);\n          } catch (error) {\n            console.error('Failed to parse WebSocket message:', error);\n          }\n        };\n        this.ws.onerror = error => {\n          console.error('WebSocket error:', error);\n          this.isConnecting = false;\n        };\n        this.ws.onclose = () => {\n          console.log('WebSocket disconnected');\n          this.isConnecting = false;\n          this.handleReconnect();\n        };\n      } catch (error) {\n        console.error('WebSocket connection error:', error);\n        this.isConnecting = false;\n        reject(error);\n      }\n    });\n  }\n  handleReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`Reconnecting... Attempt ${this.reconnectAttempts}`);\n      setTimeout(() => {\n        this.connect();\n      }, this.reconnectDelay);\n    } else {\n      console.error('Max reconnection attempts reached');\n    }\n  }\n  handleMessage(data) {\n    const handlers = this.eventHandlers.get(data.type);\n    if (handlers) {\n      handlers.forEach(handler => handler(data));\n    }\n  }\n  on(eventType, callback) {\n    if (!this.eventHandlers.has(eventType)) {\n      this.eventHandlers.set(eventType, new Set());\n    }\n    this.eventHandlers.get(eventType).add(callback);\n    return () => {\n      const handlers = this.eventHandlers.get(eventType);\n      if (handlers) {\n        handlers.delete(callback);\n      }\n    };\n  }\n  subscribeToEvent(eventType, callback) {\n    return this.on(eventType, callback);\n  }\n  sendMessage(message) {\n    var _this$ws2;\n    if (((_this$ws2 = this.ws) === null || _this$ws2 === void 0 ? void 0 : _this$ws2.readyState) === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(message));\n    } else {\n      console.error('WebSocket is not connected');\n    }\n  }\n  joinRoom(roomId) {\n    this.sendMessage({\n      type: 'join_room',\n      room_id: roomId\n    });\n  }\n  sendTyping(roomId, isTyping) {\n    this.sendMessage({\n      type: 'typing',\n      room_id: roomId,\n      is_typing: isTyping\n    });\n  }\n  disconnect() {\n    if (this.ws) {\n      this.reconnectAttempts = this.maxReconnectAttempts;\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n  isConnected() {\n    var _this$ws3;\n    return ((_this$ws3 = this.ws) === null || _this$ws3 === void 0 ? void 0 : _this$ws3.readyState) === WebSocket.OPEN;\n  }\n}\nconst websocketService = new WebSocketService();\nexport default websocketService;","map":{"version":3,"names":["WebSocketService","constructor","ws","reconnectAttempts","maxReconnectAttempts","reconnectDelay","eventHandlers","Map","isConnecting","connect","_this$ws","readyState","WebSocket","OPEN","Promise","resolve","token","localStorage","getItem","console","error","reject","WS_URL","process","env","REACT_APP_WS_URL","onopen","log","onmessage","event","data","JSON","parse","handleMessage","onerror","onclose","handleReconnect","setTimeout","handlers","get","type","forEach","handler","on","eventType","callback","has","set","Set","add","delete","subscribeToEvent","sendMessage","message","_this$ws2","send","stringify","joinRoom","roomId","room_id","sendTyping","isTyping","is_typing","disconnect","close","isConnected","_this$ws3","websocketService"],"sources":["E:/Charla_V03/frontend/src/services/websocket.js"],"sourcesContent":["class WebSocketService {\r\n  constructor() {\r\n    this.ws = null;\r\n    this.reconnectAttempts = 0;\r\n    this.maxReconnectAttempts = 5;\r\n    this.reconnectDelay = 3000;\r\n    this.eventHandlers = new Map();\r\n    this.isConnecting = false;\r\n  }\r\n\r\n  // Changed: No longer accepts userId, assumes token is in localStorage\r\n  connect() {\r\n    if (this.ws?.readyState === WebSocket.OPEN || this.isConnecting) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    const token = localStorage.getItem('token');\r\n    if (!token) {\r\n        console.error('Cannot connect to WebSocket: No token found');\r\n        return Promise.reject('No token');\r\n    }\r\n\r\n    this.isConnecting = true;\r\n    const WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000';\r\n\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        // CHANGED: Connect using query param token instead of path param\r\n        this.ws = new WebSocket(`${WS_URL}/ws?token=${token}`);\r\n\r\n        this.ws.onopen = () => {\r\n          console.log('WebSocket connected');\r\n          this.reconnectAttempts = 0;\r\n          this.isConnecting = false;\r\n          resolve();\r\n        };\r\n\r\n        this.ws.onmessage = (event) => {\r\n          try {\r\n            const data = JSON.parse(event.data);\r\n            this.handleMessage(data);\r\n          } catch (error) {\r\n            console.error('Failed to parse WebSocket message:', error);\r\n          }\r\n        };\r\n\r\n        this.ws.onerror = (error) => {\r\n          console.error('WebSocket error:', error);\r\n          this.isConnecting = false;\r\n        };\r\n\r\n        this.ws.onclose = () => {\r\n          console.log('WebSocket disconnected');\r\n          this.isConnecting = false;\r\n          this.handleReconnect();\r\n        };\r\n      } catch (error) {\r\n        console.error('WebSocket connection error:', error);\r\n        this.isConnecting = false;\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  handleReconnect() {\r\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n      this.reconnectAttempts++;\r\n      console.log(`Reconnecting... Attempt ${this.reconnectAttempts}`);\r\n      setTimeout(() => {\r\n        this.connect();\r\n      }, this.reconnectDelay);\r\n    } else {\r\n      console.error('Max reconnection attempts reached');\r\n    }\r\n  }\r\n\r\n  handleMessage(data) {\r\n    const handlers = this.eventHandlers.get(data.type);\r\n    if (handlers) {\r\n      handlers.forEach(handler => handler(data));\r\n    }\r\n  }\r\n\r\n  on(eventType, callback) {\r\n    if (!this.eventHandlers.has(eventType)) {\r\n      this.eventHandlers.set(eventType, new Set());\r\n    }\r\n    this.eventHandlers.get(eventType).add(callback);\r\n\r\n    return () => {\r\n      const handlers = this.eventHandlers.get(eventType);\r\n      if (handlers) {\r\n        handlers.delete(callback);\r\n      }\r\n    };\r\n  }\r\n\r\n  subscribeToEvent(eventType, callback) {\r\n    return this.on(eventType, callback);\r\n  }\r\n\r\n  sendMessage(message) {\r\n    if (this.ws?.readyState === WebSocket.OPEN) {\r\n      this.ws.send(JSON.stringify(message));\r\n    } else {\r\n      console.error('WebSocket is not connected');\r\n    }\r\n  }\r\n\r\n  joinRoom(roomId) {\r\n    this.sendMessage({\r\n      type: 'join_room',\r\n      room_id: roomId\r\n    });\r\n  }\r\n\r\n  sendTyping(roomId, isTyping) {\r\n    this.sendMessage({\r\n      type: 'typing',\r\n      room_id: roomId,\r\n      is_typing: isTyping\r\n    });\r\n  }\r\n\r\n  disconnect() {\r\n    if (this.ws) {\r\n      this.reconnectAttempts = this.maxReconnectAttempts;\r\n      this.ws.close();\r\n      this.ws = null;\r\n    }\r\n  }\r\n\r\n  isConnected() {\r\n    return this.ws?.readyState === WebSocket.OPEN;\r\n  }\r\n}\r\n\r\nconst websocketService = new WebSocketService();\r\nexport default websocketService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}